<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="lib/d3.js"></script>
    <script src="lib/underscore.js"></script>
    <script src="lib/simple-statistics.min.js"></script>
    <script src="lib/plotly-latest.min.js"></script>
    <script src="scripts/constants.js"></script>
    <script src="scripts/workers/webworker.js"></script>
    <script src="scripts/workers/similarityorder_calc.js"></script>
    <title>Alibaba</title>
</head>
<body>
<div id="contourDiv"></div>
<script>
    let width = window.innerWidth;
    let height = window.innerHeight;
    document.getElementById('contourDiv').style.width = width;
    document.getElementById('contourDiv').style.height = height;
    //Time records
    let startTime = new Date(),
        donePreprocess, doneResampling, doneSimilarityCalc, doneOrdering, doneDrawing;

    // d3.json('data/alibaba60s.json').then(data => {
    // d3.json('data/albbcpu1200s.json').then(data => {
    d3.json('data/albbcpu2400s.json').then(data => {
        //Remove _id field
        data.forEach(d => delete d['_id']);
        //Sort the data by time_stamp
        data.sort((a, b) => a[FIELD_TIME_STAMP] - b[FIELD_TIME_STAMP]);
        const timeSteps = Array.from(new Set(data.map(d => d[FIELD_TIME_STAMP])));
        const machines = Array.from(new Set(data.map(d => d[FIELD_MACHINE_ID])));
        //Display number of machines
        console.log('Machines: ' + machines.length);
        //Sort the machines so we can gurantee the naming order from source to target (source always < target)
        machines.sort();
        const nestedByMachines = d3.nest().key(d => d[FIELD_MACHINE_ID]).entries(data);
        //Convert into object for faster accessing.
        const machineTimeObject = _.object(nestedByMachines.map(d => [d.key, d.values]));

        //For time logging purpose.
        donePreprocess = new Date();
        console.log('Preprocess: ' + (donePreprocess - startTime) + "ms");

        //Resample the data.
        let resampleParts = [];
        for (let i = 0; i < maxWorkers; i++) {
            resampleParts.push([]);
        }

        let resampleCounter = 0;
        let timeStepsLength = timeSteps.length;
        //Split the data
        for (let i = 0; i < machines.length; i++) {
            if (machineTimeObject[machines[i]].length < timeStepsLength) {
                resampleParts[resampleCounter % maxWorkers].push(machineTimeObject[machines[i]]);
                resampleCounter++;
            }
        }

        //Start workers
        let resampleResultCounter = 0;
        resampleParts.forEach((part, i) => {
            startWorker('scripts/workers/resampling_worker.js', {
                'timeSteps': timeSteps,
                'part': part
            }, onResamplingResult, i);
        });

        function onResamplingResult(results) {
            resampleResultCounter += 1;
            results.forEach(machineTs => {
                machineTimeObject[machineTs[0][FIELD_MACHINE_ID]] = machineTs;
            });
            if (resampleResultCounter === resampleParts.length) {
                resetWorkers();
                onCompleteResampling(machineTimeObject);
                //Done re-sampling
                doneResampling = new Date();
                console.log('Done resampling: ' + (doneResampling - donePreprocess) + 'ms')
            }
        }

        function onCompleteResampling(machineTimeObject) {
            //Process all the rSqared
            let similarityResults = [];
            let similarityParts = [];
            for (let i = 0; i < maxWorkers; i++) {
                similarityParts.push([]);
            }
            let similarityCounter = 0;
            for (let i = 0; i < machines.length - 1; i++) {
                for (let j = i + 1; j < machines.length; j++) {
                    let keyI = machines[i];
                    let keyJ = machines[j];
                    let valuesI = machineTimeObject[keyI];
                    let valuesJ = machineTimeObject[keyJ];
                    let sd = {x1: valuesI, x2: valuesJ};
                    similarityParts[similarityCounter % maxWorkers].push(sd);
                    similarityCounter++;
                }
            }
            let similarityResultCounter = 0;
            //Now start a worker for each of the part
            similarityParts.forEach((part, i) => {
                startWorker('scripts/workers/similarity_worker.js', part, onSimilarityResult, i);
            });

            function onSimilarityResult(evt) {
                similarityResultCounter += 1;
                similarityResults = similarityResults.concat(evt);
                if (similarityResultCounter === similarityParts.length) {
                    resetWorkers();
                    onCompleteSimilarityCal(similarityResults);
                    doneSimilarityCalc = new Date();
                    console.log('Done similarity calculation: ' + (doneSimilarityCalc - doneResampling) + 'ms');
                }
            }

            function onCompleteSimilarityCal(similarityResults) {
                //Build the best order.
                startWorker('scripts/workers/similarityorder_worker.js', {
                    machines: machines,
                    links: similarityResults
                }, onOrderResult, 0);
            }

            function onOrderResult(orders) {
                //Done ordering
                doneOrdering = new Date();
                console.log('Done ordering: ' + (doneOrdering - doneSimilarityCalc) + 'ms');
                resetWorkers();
                //Resetting the size
                document.getElementById('contourDiv').style.height = orders.length
                //Building the data
                let contourData = {};
                contourData.x = timeSteps;
                contourData.y = orders;
                contourData.z = [];
                orders.forEach(machine => {
                    contourData.z.push(machineTimeObject[machine].map(st => st[FIELD_CPU_UTIL_PERCENT]));
                });
                contourData.type = 'contour';
                contourData.line = {
                    smoothing: 0.5,
                    color: 'rgba(0, 0, 0,0)'
                }
                drawContour('contourDiv', [contourData], 1200, orders.length);
                //Done drawing
                doneDrawing = new Date();
                console.log('Done drawing: ' + (doneDrawing - doneOrdering) + 'ms');
            }
        }
    });

    function drawContour(theDiv, data, width, height) {
        var layout = {
            autosize: false,
            width: width,
            height: height,
            margin: {
                l: 0,
                r: 0,
                b: 0,
                t: 0,
                pad: 0
            },
        };

        Plotly.newPlot(theDiv, data, layout);
    }
</script>
</body>
</html>