<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="lib/d3.js"></script>
    <script src="lib/underscore.js"></script>
    <script src="lib/simple-statistics.min.js"></script>
    <script src="scripts/constants.js"></script>
    <script src="scripts/workers/webworker.js"></script>
    <script src="scripts/workers/similarityorder_calc.js"></script>
    <script src="scripts/contourplot.js"></script>
    <title>Alibaba</title>
</head>
<body>
<div id="infoDiv"></div>
<div id="contourDiv0"></div>
<div id="contourDiv1"></div>
<div id="contourDiv2"></div>
<script>
    const theVar = 'CPU1 Temp';
    let width;
    let height;

    const colorSchemes = {
        "CPU1 Temp": d3.interpolateReds,
        "Fan1 speed": d3.interpolateBlues,
        "Power consumption": d3.interpolateGreens,
        "cpu_util_percent": d3.interpolateReds
    };
    //Info div
    let infoDiv = document.getElementById('infoDiv');
    infoDiv.innerHTML = 'configuration';
    addInfo(infoDiv, 'removeNull', removeNull);
    addInfo(infoDiv, 'oneWay', oneWay);
    addInfo(infoDiv, 'stepPenalty', stepPenalty);
    addInfo(infoDiv, 'averagePenalty', averagePenalty);
    //Time records
    let startTime = new Date(),
        donePreprocess, doneResampling, doneSimilarityCalc, doneOrdering;

    // d3.json('data/albbcpu1200s.json').then(data => {
    // d3.json('data/albbcpu2400s.json').then(data => {
    // //Remove _id field
    // data.forEach(d => delete d['_id']);
    // d3.json('data/HPCC_04Oct2018.json').then(data => {
    // d3.json('data/HPCC_21Mar2019.json').then(data => {
    // d3.json('data/HPCC_21Mar2019210.json').then(data => {
    d3.json('data/HPCC_21Mar2019_5min.json').then(data => {
        const nestedByMachines = d3.nest().key(d => d[FIELD_MACHINE_ID]).entries(data);
        //Calculate the max cpu usage
        nestedByMachines.forEach(mc => {
            mc.values.max_cpu_util_percent = d3.max(mc.values.map(d => d[theVar]));
        });

        // //TODO: Only filter in case of alibaba
        // let filteredOutMachines = nestedByMachines.filter(m => m.values.max_cpu_util_percent <= 70).map(m => m.key);
        // //Filter the data
        // data = data.filter(d => filteredOutMachines.indexOf(d[FIELD_MACHINE_ID]) < 0);

        //Sort the data by time_stamp
        data.sort((a, b) => a[FIELD_TIME_STAMP] - b[FIELD_TIME_STAMP]);
        const timeSteps = Array.from(new Set(data.map(d => d[FIELD_TIME_STAMP])));
        const machines = Array.from(new Set(data.map(d => d[FIELD_MACHINE_ID])));
        //Get the size and set the sizes
        width = timeSteps.length * 10;
        height = machines.length;

        VARIABLES.map((v, i) => {
            document.getElementById('contourDiv' + i).style.width = width;
            document.getElementById('contourDiv' + i).style.height = height;
        });
        //Display number of machines
        addInfo(infoDiv, 'Machines', machines.length);
        //Sort the machines so we can gurantee the naming order from source to target (source always < target)
        machines.sort();


        //Convert into object for faster accessing.
        const machineTimeObject = _.object(nestedByMachines.map(d => [d.key, d.values]));

        //For time logging purpose.
        donePreprocess = new Date();
        addInfo(infoDiv, 'Preprocess', (donePreprocess - startTime) + "ms");

        //Resample the data.
        let resampleParts = [];
        for (let i = 0; i < maxWorkers; i++) {
            resampleParts.push([]);
        }

        let resampleCounter = 0;
        let timeStepsLength = timeSteps.length;
        //Split the data
        for (let i = 0; i < machines.length; i++) {
            //TODO: For alibaba => should check this to reduce sampling time
            // if (machineTimeObject[machines[i]].length < timeStepsLength) {
            resampleParts[resampleCounter % maxWorkers].push(machineTimeObject[machines[i]]);
            resampleCounter++;
            // }
        }

        //Start workers
        let resampleResultCounter = 0;
        resampleParts.forEach((part, i) => {
            startWorker('scripts/workers/resampling_worker.js', {
                'timeSteps': timeSteps,
                'part': part
            }, onResamplingResult, i);
        });

        function onResamplingResult(results) {
            resampleResultCounter += 1;
            results.forEach(machineTs => {
                machineTimeObject[machineTs[0][FIELD_MACHINE_ID]] = machineTs;
            });
            if (resampleResultCounter === resampleParts.length) {
                resetWorkers();
                onCompleteResampling(machineTimeObject);
                //Done re-sampling
                doneResampling = new Date();
                addInfo(infoDiv, 'Done resampling', (doneResampling - donePreprocess) + 'ms')
            }
        }

        function onCompleteResampling(machineTimeObject) {
            //Process all the rSqared
            let similarityResults = [];
            let similarityParts = [];
            for (let i = 0; i < maxWorkers; i++) {
                similarityParts.push([]);
            }
            let similarityCounter = 0;
            for (let i = 0; i < machines.length - 1; i++) {
                for (let j = i + 1; j < machines.length; j++) {
                    let keyI = machines[i];
                    let keyJ = machines[j];
                    let valuesI = machineTimeObject[keyI];
                    let valuesJ = machineTimeObject[keyJ];
                    let sd = {x1: valuesI, x2: valuesJ};
                    similarityParts[similarityCounter % maxWorkers].push(sd);
                    similarityCounter++;
                }
            }
            let similarityResultCounter = 0;
            //Now start a worker for each of the part
            similarityParts.forEach((part, i) => {
                startWorker('scripts/workers/similarity_worker.js', part, onSimilarityResult, i);
            });

            function onSimilarityResult(evt) {

                similarityResultCounter += 1;
                similarityResults = similarityResults.concat(evt);
                if (similarityResultCounter === similarityParts.length) {
                    resetWorkers();
                    onCompleteSimilarityCal(similarityResults);

                    doneSimilarityCalc = new Date();
                    addInfo(infoDiv, 'Done similarity calculation', (doneSimilarityCalc - doneResampling) + 'ms');
                }
            }

            function onCompleteSimilarityCal(similarityResults) {
                let orderParts = VARIABLES.map((theVar) => {
                    return similarityResults.map(similarity => {
                        return {
                            source: similarity.source,
                            target: similarity.target,
                            weight: similarity.weights[theVar]
                        }
                    });
                });
                orderParts.forEach((part, i) => {
                    //Build the best order.
                    startWorker('scripts/workers/similarityorder_worker.js', {
                        theVar: VARIABLES[i],
                        machines: machines,
                        links: part
                    }, onOrderResult, i);
                });
                let orderingResultCounter = 0;

                function onOrderResult(orderResults) {

                    orderingResultCounter += 1;
                    if (orderingResultCounter === orderParts.length) {
                        doneOrdering = new Date();
                        addInfo(infoDiv, 'Done ordering', (doneOrdering - doneSimilarityCalc) + 'ms');
                        resetWorkers();
                    }
                    let theVar = orderResults.variable;

                    let startDrawing = new Date();
                    let theDiv = 'contourDiv' + VARIABLES.indexOf(theVar);
                    let order = orderResults.order;
                    //Resetting the size
                    document.getElementById(theDiv).style.height = order.length
                    //Building the data
                    let x = timeSteps;
                    let y = order;
                    let z = [];
                    order.forEach(machine => {
                        z.push(machineTimeObject[machine].map(st => st[theVar]));
                    });
                    let flatZ = z.flat();
                    let min = d3.min(flatZ) - 1;
                    // let min = d3.mean(flatZ);
                    let max = d3.max(flatZ);
                    let numOfRanges = 5;
                    let range = (max - min) / numOfRanges;
                    let thresholds = [];
                    for (let i = 0; i < numOfRanges; i++) {
                        thresholds.push(min + i * range);
                    }
                    let colors = thresholds.map(v => colorSchemes[theVar](v / max));

                    // Blue to red scheme
                    // let thresholds = [10e-3, 40, 60, 80, 90];
                    // let colors = ['#455bdc', '#9faad3', '#e39968', '#c53c33', '#b20a1c'];

                    let contourData = {
                        x: x,
                        y: y,
                        z: z,
                        thresholds: thresholds,
                        colors: colors
                    };

                    plotContour(theDiv, contourData, width, height);
                    let doneDrawing = new Date();
                    addInfo(infoDiv, 'Done drawing', (doneDrawing - startDrawing) + 'ms');
                }
            }
        }
    });
</script>
</body>
</html>