<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="lib/d3.js"></script>
    <script src="lib/underscore.js"></script>
    <script src="lib/simple-statistics.min.js"></script>
    <script src="lib/jquery.js"></script>
    <script src="lib/fisheye.js"></script>

    <script src="scripts/constants.js"></script>
    <script src="scripts/workers/webworker.js"></script>
    <script src="scripts/workers/similarityorder_calc.js"></script>
    <script src="scripts/contourplot.js"></script>
    <title>nD Heatmap</title>
    <style>
        @import 'css/floatingBox.css';
        @import 'css/floatingbutton.css';
        @import "css/main.css";

    </style>
</head>
<body>
<div id="configurationContainer" class="floatingBox">
    <div id="configurationContainerHeader" class="floatingBoxHeader"><span class="floatingBoxButton"
                                                                           onclick="closeFloatingBox('btnConfiguration', 'configurationContainer')">[-]</span>
        Configuration
    </div>
    <div class="floatingBoxContent">
        <br/>
        <b>Settings</b><br/>
        <div id="settingDiv"></div>
        <br/>
        <b>Calculations</b><br/>
        <table id="calculationTbl"></table>
        <br/>
        <b>Contour info</b><br/>
        <table id="contourTbl"></table>
    </div>
</div>

<div id="contours">
    <div id="timeLineDiv"></div>
    <div id="contourDiv"></div>
</div>
<!--section for the buttons-->
<a id="btnConfiguration" class="tab tab_right" style="opacity: 0.0;"
   onclick="openFloatingBox('btnConfiguration', 'configurationContainer')"><img src="images/tabicon.gif" alt="">Configuration<span
        class="screen_reader"> Will open a new window</span></a>

<script>
    const theVar = 'CPU1 Temp';
    const colorSchemes = {
        "CPU1 Temp": d3.interpolateReds,
        "Fan1 speed": d3.interpolateBlues,
        "Power consumption": d3.interpolateGreens,
        "cpu_util_percent": d3.interpolateReds
    };
    //Info div
    let settingDiv = document.getElementById('settingDiv');
    let calculationTbl = document.getElementById('calculationTbl');
    let settingTblStr = createTableStr([[{innerHTML: 'oneWay'}, {innerHTML: oneWay}], [{innerHTML: 'penalty'}, {innerHTML: stepPenalty}]]);
    addInfoHTML(settingDiv, settingTblStr);

    //Time records
    let startTime = new Date(),
        donePreprocess, doneResampling, doneSimilarityCalc, doneOrdering;

    // d3.json('data/albbcpu1200s.json').then(data => {
    // d3.json('data/albbcpu2400s.json').then(data => {
    // //Remove _id field
    // data.forEach(d => delete d['_id']);
    // d3.json('data/HPCC_04Oct2018.json').then(data => {
    // d3.json('data/HPCC_21Mar2019.json').then(data => {
    // d3.json('data/HPCC_21Mar2019210.json').then(data => {
    d3.json('data/HPCC_21Mar2019_5min.json').then(data => {
        const nestedByMachines = d3.nest().key(d => d[FIELD_MACHINE_ID]).entries(data);
        //Calculate the max cpu usage
        nestedByMachines.forEach(mc => {
            mc.values.max_cpu_util_percent = d3.max(mc.values.map(d => d[theVar]));
        });

        // //TODO: Only filter in case of alibaba
        // let filteredOutMachines = nestedByMachines.filter(m => m.values.max_cpu_util_percent <= 70).map(m => m.key);
        // //Filter the data
        // data = data.filter(d => filteredOutMachines.indexOf(d[FIELD_MACHINE_ID]) < 0);

        //Sort the data by time_stamp
        data.sort((a, b) => a[FIELD_TIME_STAMP] - b[FIELD_TIME_STAMP]);
        const timeSteps = Array.from(new Set(data.map(d => d[FIELD_TIME_STAMP])));
        const machines = Array.from(new Set(data.map(d => d[FIELD_MACHINE_ID])));
        //Get the size and set the sizes

        width = Math.max(Math.round(window.innerWidth * 2 / 3), timeSteps.length);
        height = Math.max(window.innerHeight, machines.length);
        pixelsPerColumn = Math.ceil(width / timeSteps.length);
        //TODO: Note: This is used for sampling of the ticks => may need to check this. When we change the number of rows to be smaller than number of machines (less than a pixel per row)
        pixelsPerRow = Math.ceil(height / machines.length);


        //We need to make sure that the width is divisible by the timeSteps, and height is divisible by machines
        width = pixelsPerColumn * timeSteps.length;
        height = pixelsPerRow * machines.length;

        fisheyeX = fisheye.scale(d3.scaleIdentity).domain([0, width]).focus(width / 2);
        fisheyeY = fisheye.scale(d3.scaleIdentity).domain([0, height]).focus(height / 2);

        svgWidth = width + margins.left + margins.right;
        svgHeight = VARIABLES.length * height + margins.top + margins.bottom;
        //Now we can draw the timeLine.
        let timeLineHeight = 30;
        let timeLineWidth = svgWidth;
        //Add the SVG for the timeline
        let timeLineSvg = d3.select('#timeLineDiv').append("svg").attr('width', timeLineWidth).attr('height', timeLineHeight);
        //Add a rect for the background
        timeLineSvg.append("rect").attr("x", 0).attr("y", 0).attr("width", timeLineWidth).attr("height", timeLineHeight).attr("fill", "white");
        //Add a line at the bottom
        timeLineSvg.append('line').attr('x1', 0).attr('y1', timeLineHeight - 1).attr('x2', timeLineWidth).attr('y2', timeLineHeight - 1)
            .attr('stroke', 'black').attr('stroke-width', 1);
        //Add a group to display the timeline to
        timeLineSvg.append("g").attr("id", "timeLineG").attr("transform", `translate(${margins.left}, ${timeLineHeight - 1})`);//-1 is for the bottom line
        drawTimeLine(timeSteps, timeLineWidth, timeLineHeight, fisheyeX);


        //Add svg and the groups for the contour plots of the variables.
        let mainSvg = d3.select(`#contourDiv`).append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight);
        let mainGroup = mainSvg
            .append("g").attr("transform", `translate(${margins.left},${margins.top})`);
        //Add the groups
        mainGroup.selectAll('.contourPlot').data(VARIABLES).enter().append("g")
            .attr('class', 'contourPlot').attr('id', (d, i) => `contourPlot${i}`)
            .attr("transform", (d, i) => `translate(0, ${i * height})`);

        //Display number of machines
        addInfoRow(calculationTbl, [{innerHTML: 'Machines'}, {
            innerHTML: machines.length,
            styles: [{key: 'textAlign', value: 'right'}]
        }]);
        //Sort the machines so we can gurantee the naming order from source to target (source always < target)
        machines.sort();


        //Convert into object for faster accessing.
        const machineTimeObject = _.object(nestedByMachines.map(d => [d.key, d.values]));

        //For time logging purpose.
        donePreprocess = new Date();
        addInfoRow(calculationTbl, [{innerHTML: 'Pre-processing'}, {
            innerHTML: (donePreprocess - startTime) + "ms",
            styles:[{key: 'textAlign', value: 'right'}]
        }]);

        //Resample the data.
        let resampleParts = [];
        for (let i = 0; i < maxWorkers; i++) {
            resampleParts.push([]);
        }

        let resampleCounter = 0;
        //Split the data
        for (let i = 0; i < machines.length; i++) {
            //TODO: For alibaba => should check this to reduce sampling time
            // if (machineTimeObject[machines[i]].length < timeStepsLength) {
            resampleParts[resampleCounter % maxWorkers].push(machineTimeObject[machines[i]]);
            resampleCounter++;
            // }
        }

        //Start workers
        let resampleResultCounter = 0;
        resampleParts.forEach((part, i) => {
            startWorker('scripts/workers/resampling_worker.js', {
                'timeSteps': timeSteps,
                'part': part
            }, onResamplingResult, i);
        });

        function onResamplingResult(results) {
            resampleResultCounter += 1;
            results.forEach(machineTs => {
                machineTimeObject[machineTs[0][FIELD_MACHINE_ID]] = machineTs;
            });
            if (resampleResultCounter === resampleParts.length) {
                resetWorkers();
                onCompleteResampling(machineTimeObject);
                //Done re-sampling
                doneResampling = new Date();
                addInfoRow(calculationTbl, [{innerHTML: 'Done resampling'}, {
                    innerHTML: (doneResampling - donePreprocess) + 'ms',
                    styles:[{key: 'textAlign', value: 'right'}]
                }]);
            }
        }

        function onCompleteResampling(machineTimeObject) {
            //Process all the rSqared
            let similarityResults = [];
            let similarityParts = [];
            for (let i = 0; i < maxWorkers; i++) {
                similarityParts.push([]);
            }
            let similarityCounter = 0;
            for (let i = 0; i < machines.length - 1; i++) {
                for (let j = i + 1; j < machines.length; j++) {
                    let keyI = machines[i];
                    let keyJ = machines[j];
                    let valuesI = machineTimeObject[keyI];
                    let valuesJ = machineTimeObject[keyJ];
                    let sd = {x1: valuesI, x2: valuesJ};
                    similarityParts[similarityCounter % maxWorkers].push(sd);
                    similarityCounter++;
                }
            }
            let similarityResultCounter = 0;
            //Now start a worker for each of the part
            similarityParts.forEach((part, i) => {
                startWorker('scripts/workers/similarity_worker.js', part, onSimilarityResult, i);
            });

            function onSimilarityResult(evt) {

                similarityResultCounter += 1;
                similarityResults = similarityResults.concat(evt);
                if (similarityResultCounter === similarityParts.length) {
                    resetWorkers();
                    onCompleteSimilarityCal(similarityResults);

                    doneSimilarityCalc = new Date();
                    addInfoRow(calculationTbl, [{innerHTML: 'Done similarity calculation'}, {
                        innerHTML: (doneSimilarityCalc - doneResampling) + 'ms',
                        styles: [{key: 'textAlign', value: 'right'}]
                    }]);
                }
            }

            function onCompleteSimilarityCal(similarityResults) {
                let orderParts = VARIABLES.map((theVar) => {
                    return similarityResults.map(similarity => {
                        return {
                            source: similarity.source,
                            target: similarity.target,
                            weight: similarity.weights[theVar]
                        }
                    });
                });
                orderParts.forEach((part, i) => {
                    //Build the best order.
                    startWorker('scripts/workers/similarityorder_worker.js', {
                        theVar: VARIABLES[i],
                        machines: machines,
                        links: part
                    }, onOrderResult, i);
                });
                let orderingResultCounter = 0;

                let totalDraws = VARIABLES.length;
                let drawingResultCounter = 0;

                function onOrderResult(orderResults) {
                    orderingResultCounter += 1;
                    if (orderingResultCounter === orderParts.length) {
                        doneOrdering = new Date();
                        addInfoRow(calculationTbl, [{innerHTML: 'Done ordering'}, {
                            innerHTML: (doneOrdering - doneSimilarityCalc) + 'ms',
                            styles: [{key: 'textAlign', value: 'right'}]
                        }]);
                        resetWorkers();
                    }
                    let theVar = orderResults.variable;

                    let startDrawing = new Date();
                    let theGroup = d3.select(`#contourPlot${VARIABLES.indexOf(theVar)}`);
                    let order = orderResults.order;

                    //Building the data
                    let x = timeSteps;
                    let y = order;
                    let z = [];
                    order.forEach(machine => {
                        z.push(machineTimeObject[machine].map(st => st[theVar]));
                    });
                    let flatZ = z.flat();
                    let min = d3.min(flatZ) - 1;
                    // let min = d3.mean(flatZ);
                    let max = d3.max(flatZ);
                    let numOfRanges = 5;
                    let range = (max - min) / numOfRanges;
                    let thresholds = [];
                    for (let i = 0; i < numOfRanges; i++) {
                        thresholds.push(min + i * range);
                    }
                    let colors = thresholds.map(v => colorSchemes[theVar](v / max));

                    // Blue to red scheme
                    // let thresholds = [10e-3, 40, 60, 80, 90];
                    // let colors = ['#455bdc', '#9faad3', '#e39968', '#c53c33', '#b20a1c'];

                    let contourData = {
                        x: x,
                        y: y,
                        z: z,
                        thresholds: thresholds,
                        colors: colors,
                        variable: theVar
                    };
                    plotContour(theGroup, contourData, width, height, onDrawingCompleted);

                    function onDrawingCompleted(theVar) {

                        drawingResultCounter += 1;
                        //Done all drawing, start processing the contour area calculation.
                        let totalPolygonLayerCount = allContours.length;
                        let polygonLayerResultCounter = 0;
                        let allContourAreas = [];
                        if (totalDraws === drawingResultCounter) {
                            //Start calculating from here
                            allContours.forEach((cl, i) => {
                                startWorker('scripts/workers/area_worker.js', cl, onLayerAreaResult, i);
                            });
                        }

                        /**
                         *
                         * @param result result will have this format {variable: theVar, layerIndex: layerIndex, 'areas': results, layerValue: layerValue}
                         */
                        function onLayerAreaResult(result) {
                            allContourAreas.push(result);
                            polygonLayerResultCounter += 1;
                            if (polygonLayerResultCounter === totalPolygonLayerCount) {
                                resetWorkers();
                                //Display contour info area.
                                displayContourAreasInfo(allContourAreas);
                                //After all, process the sticky now here (since once done display we will have the offset information.
                                setupScrollStickyTimeLine();
                            }
                        }
                    }

                    let doneDrawing = new Date();
                    addInfoRow(calculationTbl, [{innerHTML: `Done drawing ${theVar}`}, {
                        innerHTML: (doneDrawing - startDrawing) + 'ms',
                        styles:[{key: 'textAlign', value: 'right'}]
                    }]);

                }

            }
        }

        function displayContourAreasInfo(allContourAreas) {
            let theTbl = document.getElementById('contourTbl');
            allContourAreas.sort((a, b) => {
                return a.variable !== b.variable ? a.variable.localeCompare(b.variable) : a.layerIndex - b.layerIndex;
            });
            let nestedByVariable = d3.nest().key(d=>d.variable).entries(allContourAreas);

            nestedByVariable.forEach(variable=>{
                variable.values.forEach((vl, i)=>{
                    let row = [];
                    if(i===0){
                        //Variable name is expanded in all rows + 1 for the total
                        row.push({innerHTML: vl.variable, attributes: [{key: 'rowspan', value: variable.values.length +1}]});
                        //Label is extended in all rows
                        row.push({innerHTML: 'Layer Index', attributes: [{key: 'rowspan', value: variable.values.length}]});
                    }
                    row.push({innerHTML: vl.layerIndex, styles: [{key: 'backgroundColor', value: allColorScales[vl.variable](vl.layerValue)}, {key: 'textAlign', value: 'right'}]})
                    if(i==0){
                        //Label is extended in all rows
                        row.push({innerHTML: 'Area count', attributes: [{key: 'rowspan', value: variable.values.length}]});
                    }
                    row.push({innerHTML: vl.areas.length, styles: [{key: 'backgroundColor', value: allColorScales[vl.variable](vl.layerValue)}, {key: 'textAlign', value: 'right'}]});
                    if(i==0){
                        //Label is extended in all rows
                        row.push({innerHTML: 'Area subtotal', attributes: [{key: 'rowspan', value: variable.values.length}]});
                    }
                    row.push({innerHTML: numberWithCommas(Math.round(d3.sum(vl.areas))), styles: [{key: 'backgroundColor', value: allColorScales[vl.variable](vl.layerValue)}, {key: 'textAlign', value: 'right'}]});
                    addInfoRow(theTbl, row);
                });
                //Add row for the total
                let totalR = [];
                //Total layers
                totalR.push({innerHTML: 'Total', styles: [{key: 'font-weight', value: 'bold'}]});
                totalR.push({innerHTML: variable.values.length, styles:[{key: 'textAlign', value: 'right'}]});
                //Total Area count
                totalR.push({innerHTML: 'Total', styles: [{key: 'font-weight', value: 'bold'}]});
                totalR.push({innerHTML: d3.sum(variable.values.map(vl=>vl.areas.length)), styles:[{key: 'textAlign', value: 'right'}]});
                //Total Area count
                totalR.push({innerHTML: 'Total', styles: [{key: 'font-weight', value: 'bold'}]});
                totalR.push({innerHTML: numberWithCommas(d3.sum(variable.values.map(vl=>Math.round(d3.sum(vl.areas))))), styles:[{key: 'textAlign', value: 'right'}]});
                addInfoRow(theTbl, totalR);
            });
        }

        //Setup mouseover on the svg.
        mainSvg.on("mousemove", function () {
            let mouse = d3.mouse(this);
            let mouseX = mouse[0] - margins.left;
            let mouseY = mouse[1] - margins.top;
            //If out of bound simply reset
            if (mouseX <= 0 || mouseX >= width || mouseY <= 0 || mouseY >= VARIABLES.length * height) {
                return;
            }

            //Check which group
            let groupIndex = Math.floor(mouseY / height);
            mouseY = mouseY - groupIndex * height;
            fisheyeX.focus(mouseX);
            fisheyeY.focus(mouseY);
            //First element
            let contourPlot = d3.select(`#contourPlot${groupIndex}`);
            plotContour(contourPlot, contourPlot.node().contourData, width, height, () => {
            }, fisheyeX, fisheyeY);
            //Redraw timeline
            drawTimeLine(timeSteps, timeLineWidth, timeLineHeight, fisheyeX);
        });
    });

    function setupScrollStickyTimeLine() {
        window.onscroll = processScroll;
        let timeLine = document.getElementById("timeLineDiv");
        let sticky = timeLine.offsetTop;

        function processScroll() {
            if (window.pageYOffset >= sticky) {
                timeLine.classList.add("sticky")
            } else {
                timeLine.classList.remove("sticky");
            }
        }
    }
    function numberWithCommas(x) {
        return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
</script>
<script src="scripts/floatingBox.js"></script>
</body>
</html>